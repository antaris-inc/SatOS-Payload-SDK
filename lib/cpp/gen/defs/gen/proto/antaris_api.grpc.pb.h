// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: defs/gen/proto/antaris_api.proto
// Original file comments:
// //////////////////////////////////////////////////////////
//
//  
//
//  Copyright 2022 Antaris, Inc.
//
//  
//
//  Licensed under the Apache License, Version 2.0 (the 'License');
//
//  you may not use this file except in compliance with the License.
//
//  You may obtain a copy of the License at
//
//  
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  
//
//  Unless required by applicable law or agreed to in writing, software
//
//  distributed under the License is distributed on an 'AS IS' BASIS,
//
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
//  See the License for the specific language governing permissions and
//
//  limitations under the License.
//
//  
//
//  Copyright: Copyright 2022 Antaris, Inc.
//
//  This is an autogenerated file. Any changes made to this file would likely be over-written at build time.
//
//  Generated-From: antaris_api.xml
//
//
// //////////////////////////////////////////////////////////
//
#ifndef GRPC_defs_2fgen_2fproto_2fantaris_5fapi_2eproto__INCLUDED
#define GRPC_defs_2fgen_2fproto_2fantaris_5fapi_2eproto__INCLUDED

#include "defs/gen/proto/antaris_api.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace antaris_api_peer_to_peer {

class AntarisapiApplicationCallback final {
 public:
  static constexpr char const* service_full_name() {
    return "antaris_api_peer_to_peer.AntarisapiApplicationCallback";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status PA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_StartSequenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_StartSequenceRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ShutdownAppRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ShutdownAppRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessHealthCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessHealthCheckRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponseRegisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponseRegisterRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponseGetCurrentLocationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponseGetCurrentLocationRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponseStageFileDownloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponseStageFileDownloadRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponsePayloadPowerControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponsePayloadPowerControlRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessReqPayloadMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessReqPayloadMetricsRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessRespGnssEphStopDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespGnssEphStopDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespGnssEphStopDataReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespGnssEphStopDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespGnssEphStopDataReqRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessRespGnssEphStartDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespGnssEphStartDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespGnssEphStartDataReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespGnssEphStartDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespGnssEphStartDataReqRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessGnssEphData(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GnssEphData& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessGnssEphData(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GnssEphData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessGnssEphDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessGnssEphData(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GnssEphData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessGnssEphDataRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessRespGetEpsVoltageStopReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespGetEpsVoltageStopReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespGetEpsVoltageStopReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespGetEpsVoltageStopReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespGetEpsVoltageStopReqRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessRespGetEpsVoltageStartReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespGetEpsVoltageStartReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespGetEpsVoltageStartReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespGetEpsVoltageStartReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespGetEpsVoltageStartReqRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessGetEpsVoltage(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessGetEpsVoltage(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessGetEpsVoltageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessGetEpsVoltage(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessGetEpsVoltageRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessRespStartSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespStartSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespStartSesThermMgmntReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespStartSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespStartSesThermMgmntReqRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessRespStopSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespStopSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespStopSesThermMgmntReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespStopSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespStopSesThermMgmntReqRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessRespSesTempReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespSesTempReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespSesTempReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespSesTempReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespSesTempReqRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessSesThrmlNtf(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessSesThrmlNtf(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessSesThrmlNtfRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessSesThrmlNtf(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessSesThrmlNtfRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessRespPaSatOsMsg(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespPaSatOsMsg(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespPaSatOsMsgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespPaSatOsMsg(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespPaSatOsMsgRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void PA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessRespGnssEphStopDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessRespGnssEphStopDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessRespGnssEphStartDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessRespGnssEphStartDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessGnssEphData(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GnssEphData* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessGnssEphData(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GnssEphData* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessRespGetEpsVoltageStopReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessRespGetEpsVoltageStopReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessRespGetEpsVoltageStartReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessRespGetEpsVoltageStartReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessGetEpsVoltage(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessGetEpsVoltage(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessRespStartSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessRespStartSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessRespStopSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessRespStopSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessRespSesTempReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessRespSesTempReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessSesThrmlNtf(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessSesThrmlNtf(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessRespPaSatOsMsg(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessRespPaSatOsMsg(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_StartSequenceRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_StartSequenceRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ShutdownAppRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ShutdownAppRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessHealthCheckRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessHealthCheckRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponseRegisterRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponseRegisterRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponseGetCurrentLocationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponseGetCurrentLocationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponseStageFileDownloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponseStageFileDownloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponsePayloadPowerControlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponsePayloadPowerControlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessReqPayloadMetricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessReqPayloadMetricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespGnssEphStopDataReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespGnssEphStopDataReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespGnssEphStartDataReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespGnssEphStartDataReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessGnssEphDataRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GnssEphData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessGnssEphDataRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GnssEphData& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespGetEpsVoltageStopReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespGetEpsVoltageStopReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespGetEpsVoltageStartReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespGetEpsVoltageStartReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessGetEpsVoltageRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessGetEpsVoltageRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespStartSesThermMgmntReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespStartSesThermMgmntReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespStopSesThermMgmntReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespStopSesThermMgmntReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespSesTempReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespSesTempReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessSesThrmlNtfRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessSesThrmlNtfRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespPaSatOsMsgRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespPaSatOsMsgRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status PA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_StartSequenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_StartSequenceRaw(context, request, cq));
    }
    ::grpc::Status PA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ShutdownAppRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ShutdownAppRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessHealthCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessHealthCheckRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponseRegisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponseRegisterRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponseGetCurrentLocationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponseGetCurrentLocationRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponseStageFileDownloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponseStageFileDownloadRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponsePayloadPowerControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponsePayloadPowerControlRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessReqPayloadMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessReqPayloadMetricsRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessRespGnssEphStopDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespGnssEphStopDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespGnssEphStopDataReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespGnssEphStopDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespGnssEphStopDataReqRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessRespGnssEphStartDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespGnssEphStartDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespGnssEphStartDataReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespGnssEphStartDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespGnssEphStartDataReqRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessGnssEphData(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GnssEphData& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessGnssEphData(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GnssEphData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessGnssEphDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessGnssEphData(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GnssEphData& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessGnssEphDataRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessRespGetEpsVoltageStopReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespGetEpsVoltageStopReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespGetEpsVoltageStopReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespGetEpsVoltageStopReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespGetEpsVoltageStopReqRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessRespGetEpsVoltageStartReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespGetEpsVoltageStartReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespGetEpsVoltageStartReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespGetEpsVoltageStartReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespGetEpsVoltageStartReqRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessGetEpsVoltage(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessGetEpsVoltage(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessGetEpsVoltageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessGetEpsVoltage(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessGetEpsVoltageRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessRespStartSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespStartSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespStartSesThermMgmntReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespStartSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespStartSesThermMgmntReqRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessRespStopSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespStopSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespStopSesThermMgmntReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespStopSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespStopSesThermMgmntReqRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessRespSesTempReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespSesTempReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespSesTempReqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespSesTempReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespSesTempReqRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessSesThrmlNtf(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessSesThrmlNtf(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessSesThrmlNtfRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessSesThrmlNtf(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessSesThrmlNtfRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessRespPaSatOsMsg(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessRespPaSatOsMsg(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessRespPaSatOsMsgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessRespPaSatOsMsg(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessRespPaSatOsMsgRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void PA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessRespGnssEphStopDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessRespGnssEphStopDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessRespGnssEphStartDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessRespGnssEphStartDataReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessGnssEphData(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GnssEphData* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessGnssEphData(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GnssEphData* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessRespGetEpsVoltageStopReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessRespGetEpsVoltageStopReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessRespGetEpsVoltageStartReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessRespGetEpsVoltageStartReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessGetEpsVoltage(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessGetEpsVoltage(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessRespStartSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessRespStartSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessRespStopSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessRespStopSesThermMgmntReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessRespSesTempReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessRespSesTempReq(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessSesThrmlNtf(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessSesThrmlNtf(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessRespPaSatOsMsg(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessRespPaSatOsMsg(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_StartSequenceRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_StartSequenceRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ShutdownAppRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ShutdownAppRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessHealthCheckRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessHealthCheckRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponseRegisterRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponseRegisterRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponseGetCurrentLocationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponseGetCurrentLocationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponseStageFileDownloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponseStageFileDownloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponsePayloadPowerControlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponsePayloadPowerControlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessReqPayloadMetricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessReqPayloadMetricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespGnssEphStopDataReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespGnssEphStopDataReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespGnssEphStartDataReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespGnssEphStartDataReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessGnssEphDataRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GnssEphData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessGnssEphDataRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GnssEphData& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespGetEpsVoltageStopReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespGetEpsVoltageStopReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespGetEpsVoltageStartReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespGetEpsVoltageStartReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessGetEpsVoltageRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessGetEpsVoltageRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespStartSesThermMgmntReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespStartSesThermMgmntReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespStopSesThermMgmntReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespStopSesThermMgmntReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespSesTempReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespSesTempReqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessSesThrmlNtfRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessSesThrmlNtfRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessRespPaSatOsMsgRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessRespPaSatOsMsgRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_PA_StartSequence_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ShutdownApp_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessHealthCheck_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessResponseRegister_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessResponseGetCurrentLocation_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessResponseStageFileDownload_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessResponsePayloadPowerControl_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessReqPayloadMetrics_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessRespGnssEphStopDataReq_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessRespGnssEphStartDataReq_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessGnssEphData_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessRespGetEpsVoltageStopReq_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessRespGetEpsVoltageStartReq_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessGetEpsVoltage_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessRespStartSesThermMgmntReq_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessRespStopSesThermMgmntReq_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessRespSesTempReq_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessSesThrmlNtf_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessRespPaSatOsMsg_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status PA_StartSequence(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ShutdownApp(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessHealthCheck(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessResponseRegister(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessRespGnssEphStopDataReq(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessRespGnssEphStartDataReq(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessGnssEphData(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::GnssEphData* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessRespGetEpsVoltageStopReq(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessRespGetEpsVoltageStartReq(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessGetEpsVoltage(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessRespStartSesThermMgmntReq(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessRespStopSesThermMgmntReq(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessRespSesTempReq(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessSesThrmlNtf(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessRespPaSatOsMsg(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_StartSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_StartSequence() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_PA_StartSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_StartSequence(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSequenceParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_StartSequence(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::StartSequenceParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ShutdownApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ShutdownApp() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_PA_ShutdownApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ShutdownApp(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ShutdownApp(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ShutdownParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessHealthCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessHealthCheck() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_PA_ProcessHealthCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessHealthCheck(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::HealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessHealthCheck(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::HealthCheckParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessResponseRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessResponseRegister() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_PA_ProcessResponseRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseRegister(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponseRegister(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespRegisterParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessResponseGetCurrentLocation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessResponseGetCurrentLocation() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_PA_ProcessResponseGetCurrentLocation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessResponseStageFileDownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessResponseStageFileDownload() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_PA_ProcessResponseStageFileDownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponseStageFileDownload(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespStageFileDownloadParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessResponsePayloadPowerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessResponsePayloadPowerControl() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_PA_ProcessResponsePayloadPowerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessReqPayloadMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessReqPayloadMetrics() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_PA_ProcessReqPayloadMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessReqPayloadMetrics(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessRespGnssEphStopDataReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessRespGnssEphStopDataReq() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_PA_ProcessRespGnssEphStopDataReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGnssEphStopDataReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespGnssEphStopDataReq(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespGnssEphStopDataReq* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessRespGnssEphStartDataReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessRespGnssEphStartDataReq() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_PA_ProcessRespGnssEphStartDataReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGnssEphStartDataReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespGnssEphStartDataReq(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespGnssEphStartDataReq* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessGnssEphData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessGnssEphData() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_PA_ProcessGnssEphData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessGnssEphData(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::GnssEphData* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessGnssEphData(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::GnssEphData* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessRespGetEpsVoltageStopReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessRespGetEpsVoltageStopReq() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_PA_ProcessRespGetEpsVoltageStopReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGetEpsVoltageStopReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespGetEpsVoltageStopReq(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessRespGetEpsVoltageStartReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessRespGetEpsVoltageStartReq() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_PA_ProcessRespGetEpsVoltageStartReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGetEpsVoltageStartReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespGetEpsVoltageStartReq(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessGetEpsVoltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessGetEpsVoltage() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_PA_ProcessGetEpsVoltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessGetEpsVoltage(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::GetEpsVoltage* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessGetEpsVoltage(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::GetEpsVoltage* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessRespStartSesThermMgmntReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessRespStartSesThermMgmntReq() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_PA_ProcessRespStartSesThermMgmntReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespStartSesThermMgmntReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespStartSesThermMgmntReq(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessRespStopSesThermMgmntReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessRespStopSesThermMgmntReq() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_PA_ProcessRespStopSesThermMgmntReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespStopSesThermMgmntReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespStopSesThermMgmntReq(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessRespSesTempReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessRespSesTempReq() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_PA_ProcessRespSesTempReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespSesTempReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespSesTempReqParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespSesTempReq(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespSesTempReqParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessSesThrmlNtf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessSesThrmlNtf() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_PA_ProcessSesThrmlNtf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessSesThrmlNtf(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::SesThermalStatusNtf* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessSesThrmlNtf(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::SesThermalStatusNtf* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessRespPaSatOsMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessRespPaSatOsMsg() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_PA_ProcessRespPaSatOsMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespPaSatOsMsg(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPaSatOsMsg* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespPaSatOsMsg(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespPaSatOsMsg* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_PA_StartSequence<WithAsyncMethod_PA_ShutdownApp<WithAsyncMethod_PA_ProcessHealthCheck<WithAsyncMethod_PA_ProcessResponseRegister<WithAsyncMethod_PA_ProcessResponseGetCurrentLocation<WithAsyncMethod_PA_ProcessResponseStageFileDownload<WithAsyncMethod_PA_ProcessResponsePayloadPowerControl<WithAsyncMethod_PA_ProcessReqPayloadMetrics<WithAsyncMethod_PA_ProcessRespGnssEphStopDataReq<WithAsyncMethod_PA_ProcessRespGnssEphStartDataReq<WithAsyncMethod_PA_ProcessGnssEphData<WithAsyncMethod_PA_ProcessRespGetEpsVoltageStopReq<WithAsyncMethod_PA_ProcessRespGetEpsVoltageStartReq<WithAsyncMethod_PA_ProcessGetEpsVoltage<WithAsyncMethod_PA_ProcessRespStartSesThermMgmntReq<WithAsyncMethod_PA_ProcessRespStopSesThermMgmntReq<WithAsyncMethod_PA_ProcessRespSesTempReq<WithAsyncMethod_PA_ProcessSesThrmlNtf<WithAsyncMethod_PA_ProcessRespPaSatOsMsg<Service > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_PA_StartSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_StartSequence() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::StartSequenceParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_StartSequence(context, request, response); }));}
    void SetMessageAllocatorFor_PA_StartSequence(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::StartSequenceParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::StartSequenceParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_StartSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_StartSequence(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSequenceParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_StartSequence(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSequenceParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ShutdownApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ShutdownApp() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ShutdownApp(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ShutdownApp(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ShutdownApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ShutdownApp(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ShutdownApp(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessHealthCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessHealthCheck() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::HealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessHealthCheck(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessHealthCheck(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::HealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::HealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessHealthCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessHealthCheck(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::HealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessHealthCheck(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::HealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessResponseRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessResponseRegister() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessResponseRegister(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessResponseRegister(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessResponseRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseRegister(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponseRegister(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessResponseGetCurrentLocation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessResponseGetCurrentLocation() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessResponseGetCurrentLocation(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessResponseGetCurrentLocation(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessResponseGetCurrentLocation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponseGetCurrentLocation(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessResponseStageFileDownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessResponseStageFileDownload() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessResponseStageFileDownload(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessResponseStageFileDownload(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessResponseStageFileDownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponseStageFileDownload(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessResponsePayloadPowerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessResponsePayloadPowerControl() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessResponsePayloadPowerControl(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessResponsePayloadPowerControl(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessResponsePayloadPowerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponsePayloadPowerControl(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessReqPayloadMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessReqPayloadMetrics() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqPayloadMetricsParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessReqPayloadMetrics(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessReqPayloadMetrics(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ReqPayloadMetricsParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqPayloadMetricsParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessReqPayloadMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessReqPayloadMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessRespGnssEphStopDataReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessRespGnssEphStopDataReq() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespGnssEphStopDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessRespGnssEphStopDataReq(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessRespGnssEphStopDataReq(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespGnssEphStopDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespGnssEphStopDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessRespGnssEphStopDataReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGnssEphStopDataReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespGnssEphStopDataReq(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessRespGnssEphStartDataReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessRespGnssEphStartDataReq() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespGnssEphStartDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessRespGnssEphStartDataReq(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessRespGnssEphStartDataReq(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespGnssEphStartDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespGnssEphStartDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessRespGnssEphStartDataReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGnssEphStartDataReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespGnssEphStartDataReq(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessGnssEphData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessGnssEphData() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::GnssEphData, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::GnssEphData* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessGnssEphData(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessGnssEphData(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::GnssEphData, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::GnssEphData, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessGnssEphData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessGnssEphData(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::GnssEphData* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessGnssEphData(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::GnssEphData* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessRespGetEpsVoltageStopReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessRespGetEpsVoltageStopReq() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessRespGetEpsVoltageStopReq(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessRespGetEpsVoltageStopReq(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessRespGetEpsVoltageStopReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGetEpsVoltageStopReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespGetEpsVoltageStopReq(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessRespGetEpsVoltageStartReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessRespGetEpsVoltageStartReq() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessRespGetEpsVoltageStartReq(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessRespGetEpsVoltageStartReq(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessRespGetEpsVoltageStartReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGetEpsVoltageStartReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespGetEpsVoltageStartReq(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessGetEpsVoltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessGetEpsVoltage() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::GetEpsVoltage, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::GetEpsVoltage* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessGetEpsVoltage(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessGetEpsVoltage(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::GetEpsVoltage, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::GetEpsVoltage, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessGetEpsVoltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessGetEpsVoltage(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::GetEpsVoltage* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessGetEpsVoltage(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::GetEpsVoltage* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessRespStartSesThermMgmntReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessRespStartSesThermMgmntReq() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessRespStartSesThermMgmntReq(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessRespStartSesThermMgmntReq(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessRespStartSesThermMgmntReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespStartSesThermMgmntReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespStartSesThermMgmntReq(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessRespStopSesThermMgmntReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessRespStopSesThermMgmntReq() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessRespStopSesThermMgmntReq(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessRespStopSesThermMgmntReq(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessRespStopSesThermMgmntReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespStopSesThermMgmntReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespStopSesThermMgmntReq(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessRespSesTempReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessRespSesTempReq() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespSesTempReqParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespSesTempReqParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessRespSesTempReq(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessRespSesTempReq(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespSesTempReqParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespSesTempReqParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessRespSesTempReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespSesTempReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespSesTempReqParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespSesTempReq(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespSesTempReqParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessSesThrmlNtf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessSesThrmlNtf() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::SesThermalStatusNtf, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::SesThermalStatusNtf* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessSesThrmlNtf(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessSesThrmlNtf(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::SesThermalStatusNtf, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::SesThermalStatusNtf, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessSesThrmlNtf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessSesThrmlNtf(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::SesThermalStatusNtf* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessSesThrmlNtf(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::SesThermalStatusNtf* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessRespPaSatOsMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessRespPaSatOsMsg() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespPaSatOsMsg, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespPaSatOsMsg* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessRespPaSatOsMsg(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessRespPaSatOsMsg(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespPaSatOsMsg, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespPaSatOsMsg, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessRespPaSatOsMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespPaSatOsMsg(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPaSatOsMsg* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespPaSatOsMsg(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPaSatOsMsg* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_PA_StartSequence<WithCallbackMethod_PA_ShutdownApp<WithCallbackMethod_PA_ProcessHealthCheck<WithCallbackMethod_PA_ProcessResponseRegister<WithCallbackMethod_PA_ProcessResponseGetCurrentLocation<WithCallbackMethod_PA_ProcessResponseStageFileDownload<WithCallbackMethod_PA_ProcessResponsePayloadPowerControl<WithCallbackMethod_PA_ProcessReqPayloadMetrics<WithCallbackMethod_PA_ProcessRespGnssEphStopDataReq<WithCallbackMethod_PA_ProcessRespGnssEphStartDataReq<WithCallbackMethod_PA_ProcessGnssEphData<WithCallbackMethod_PA_ProcessRespGetEpsVoltageStopReq<WithCallbackMethod_PA_ProcessRespGetEpsVoltageStartReq<WithCallbackMethod_PA_ProcessGetEpsVoltage<WithCallbackMethod_PA_ProcessRespStartSesThermMgmntReq<WithCallbackMethod_PA_ProcessRespStopSesThermMgmntReq<WithCallbackMethod_PA_ProcessRespSesTempReq<WithCallbackMethod_PA_ProcessSesThrmlNtf<WithCallbackMethod_PA_ProcessRespPaSatOsMsg<Service > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_PA_StartSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_StartSequence() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_PA_StartSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_StartSequence(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSequenceParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ShutdownApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ShutdownApp() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_PA_ShutdownApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ShutdownApp(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessHealthCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessHealthCheck() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_PA_ProcessHealthCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessHealthCheck(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::HealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessResponseRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessResponseRegister() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_PA_ProcessResponseRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseRegister(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessResponseGetCurrentLocation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessResponseGetCurrentLocation() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_PA_ProcessResponseGetCurrentLocation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessResponseStageFileDownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessResponseStageFileDownload() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_PA_ProcessResponseStageFileDownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessResponsePayloadPowerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessResponsePayloadPowerControl() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_PA_ProcessResponsePayloadPowerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessReqPayloadMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessReqPayloadMetrics() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_PA_ProcessReqPayloadMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessRespGnssEphStopDataReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessRespGnssEphStopDataReq() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_PA_ProcessRespGnssEphStopDataReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGnssEphStopDataReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessRespGnssEphStartDataReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessRespGnssEphStartDataReq() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_PA_ProcessRespGnssEphStartDataReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGnssEphStartDataReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessGnssEphData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessGnssEphData() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_PA_ProcessGnssEphData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessGnssEphData(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::GnssEphData* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessRespGetEpsVoltageStopReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessRespGetEpsVoltageStopReq() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_PA_ProcessRespGetEpsVoltageStopReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGetEpsVoltageStopReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessRespGetEpsVoltageStartReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessRespGetEpsVoltageStartReq() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_PA_ProcessRespGetEpsVoltageStartReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGetEpsVoltageStartReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessGetEpsVoltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessGetEpsVoltage() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_PA_ProcessGetEpsVoltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessGetEpsVoltage(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::GetEpsVoltage* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessRespStartSesThermMgmntReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessRespStartSesThermMgmntReq() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_PA_ProcessRespStartSesThermMgmntReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespStartSesThermMgmntReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessRespStopSesThermMgmntReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessRespStopSesThermMgmntReq() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_PA_ProcessRespStopSesThermMgmntReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespStopSesThermMgmntReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessRespSesTempReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessRespSesTempReq() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_PA_ProcessRespSesTempReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespSesTempReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespSesTempReqParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessSesThrmlNtf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessSesThrmlNtf() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_PA_ProcessSesThrmlNtf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessSesThrmlNtf(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::SesThermalStatusNtf* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessRespPaSatOsMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessRespPaSatOsMsg() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_PA_ProcessRespPaSatOsMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespPaSatOsMsg(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPaSatOsMsg* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_StartSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_StartSequence() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_PA_StartSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_StartSequence(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSequenceParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_StartSequence(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ShutdownApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ShutdownApp() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_PA_ShutdownApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ShutdownApp(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ShutdownApp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessHealthCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessHealthCheck() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_PA_ProcessHealthCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessHealthCheck(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::HealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessHealthCheck(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessResponseRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessResponseRegister() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_PA_ProcessResponseRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseRegister(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponseRegister(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessResponseGetCurrentLocation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessResponseGetCurrentLocation() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_PA_ProcessResponseGetCurrentLocation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessResponseStageFileDownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessResponseStageFileDownload() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_PA_ProcessResponseStageFileDownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponseStageFileDownload(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessResponsePayloadPowerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessResponsePayloadPowerControl() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_PA_ProcessResponsePayloadPowerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessReqPayloadMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessReqPayloadMetrics() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_PA_ProcessReqPayloadMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessReqPayloadMetrics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessRespGnssEphStopDataReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessRespGnssEphStopDataReq() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_PA_ProcessRespGnssEphStopDataReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGnssEphStopDataReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespGnssEphStopDataReq(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessRespGnssEphStartDataReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessRespGnssEphStartDataReq() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_PA_ProcessRespGnssEphStartDataReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGnssEphStartDataReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespGnssEphStartDataReq(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessGnssEphData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessGnssEphData() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_PA_ProcessGnssEphData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessGnssEphData(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::GnssEphData* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessGnssEphData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessRespGetEpsVoltageStopReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessRespGetEpsVoltageStopReq() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_PA_ProcessRespGetEpsVoltageStopReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGetEpsVoltageStopReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespGetEpsVoltageStopReq(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessRespGetEpsVoltageStartReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessRespGetEpsVoltageStartReq() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_PA_ProcessRespGetEpsVoltageStartReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGetEpsVoltageStartReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespGetEpsVoltageStartReq(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessGetEpsVoltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessGetEpsVoltage() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_PA_ProcessGetEpsVoltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessGetEpsVoltage(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::GetEpsVoltage* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessGetEpsVoltage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessRespStartSesThermMgmntReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessRespStartSesThermMgmntReq() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_PA_ProcessRespStartSesThermMgmntReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespStartSesThermMgmntReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespStartSesThermMgmntReq(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessRespStopSesThermMgmntReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessRespStopSesThermMgmntReq() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_PA_ProcessRespStopSesThermMgmntReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespStopSesThermMgmntReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespStopSesThermMgmntReq(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessRespSesTempReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessRespSesTempReq() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_PA_ProcessRespSesTempReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespSesTempReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespSesTempReqParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespSesTempReq(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessSesThrmlNtf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessSesThrmlNtf() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_PA_ProcessSesThrmlNtf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessSesThrmlNtf(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::SesThermalStatusNtf* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessSesThrmlNtf(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessRespPaSatOsMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessRespPaSatOsMsg() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_PA_ProcessRespPaSatOsMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespPaSatOsMsg(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPaSatOsMsg* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessRespPaSatOsMsg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_StartSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_StartSequence() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_StartSequence(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_StartSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_StartSequence(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSequenceParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_StartSequence(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ShutdownApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ShutdownApp() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ShutdownApp(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ShutdownApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ShutdownApp(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ShutdownApp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessHealthCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessHealthCheck() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessHealthCheck(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessHealthCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessHealthCheck(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::HealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessHealthCheck(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessResponseRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessResponseRegister() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessResponseRegister(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessResponseRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseRegister(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponseRegister(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessResponseGetCurrentLocation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessResponseGetCurrentLocation() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessResponseGetCurrentLocation(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessResponseGetCurrentLocation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponseGetCurrentLocation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessResponseStageFileDownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessResponseStageFileDownload() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessResponseStageFileDownload(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessResponseStageFileDownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponseStageFileDownload(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessResponsePayloadPowerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessResponsePayloadPowerControl() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessResponsePayloadPowerControl(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessResponsePayloadPowerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponsePayloadPowerControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessReqPayloadMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessReqPayloadMetrics() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessReqPayloadMetrics(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessReqPayloadMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessReqPayloadMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessRespGnssEphStopDataReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessRespGnssEphStopDataReq() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessRespGnssEphStopDataReq(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessRespGnssEphStopDataReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGnssEphStopDataReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespGnssEphStopDataReq(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessRespGnssEphStartDataReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessRespGnssEphStartDataReq() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessRespGnssEphStartDataReq(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessRespGnssEphStartDataReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGnssEphStartDataReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespGnssEphStartDataReq(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessGnssEphData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessGnssEphData() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessGnssEphData(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessGnssEphData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessGnssEphData(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::GnssEphData* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessGnssEphData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessRespGetEpsVoltageStopReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessRespGetEpsVoltageStopReq() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessRespGetEpsVoltageStopReq(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessRespGetEpsVoltageStopReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGetEpsVoltageStopReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespGetEpsVoltageStopReq(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessRespGetEpsVoltageStartReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessRespGetEpsVoltageStartReq() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessRespGetEpsVoltageStartReq(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessRespGetEpsVoltageStartReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespGetEpsVoltageStartReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespGetEpsVoltageStartReq(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessGetEpsVoltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessGetEpsVoltage() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessGetEpsVoltage(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessGetEpsVoltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessGetEpsVoltage(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::GetEpsVoltage* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessGetEpsVoltage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessRespStartSesThermMgmntReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessRespStartSesThermMgmntReq() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessRespStartSesThermMgmntReq(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessRespStartSesThermMgmntReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespStartSesThermMgmntReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespStartSesThermMgmntReq(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessRespStopSesThermMgmntReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessRespStopSesThermMgmntReq() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessRespStopSesThermMgmntReq(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessRespStopSesThermMgmntReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespStopSesThermMgmntReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespStopSesThermMgmntReq(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessRespSesTempReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessRespSesTempReq() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessRespSesTempReq(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessRespSesTempReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespSesTempReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespSesTempReqParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespSesTempReq(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessSesThrmlNtf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessSesThrmlNtf() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessSesThrmlNtf(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessSesThrmlNtf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessSesThrmlNtf(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::SesThermalStatusNtf* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessSesThrmlNtf(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessRespPaSatOsMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessRespPaSatOsMsg() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessRespPaSatOsMsg(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessRespPaSatOsMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessRespPaSatOsMsg(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPaSatOsMsg* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessRespPaSatOsMsg(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_StartSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_StartSequence() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::StartSequenceParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::StartSequenceParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_StartSequence(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_StartSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_StartSequence(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSequenceParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_StartSequence(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::StartSequenceParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ShutdownApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ShutdownApp() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ShutdownApp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ShutdownApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ShutdownApp(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ShutdownApp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ShutdownParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessHealthCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessHealthCheck() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::HealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::HealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessHealthCheck(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessHealthCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessHealthCheck(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::HealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessHealthCheck(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::HealthCheckParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessResponseRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessResponseRegister() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessResponseRegister(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessResponseRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessResponseRegister(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessResponseRegister(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespRegisterParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessResponseGetCurrentLocation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessResponseGetCurrentLocation() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessResponseGetCurrentLocation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessResponseGetCurrentLocation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespGetCurrentLocationParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessResponseStageFileDownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessResponseStageFileDownload() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessResponseStageFileDownload(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessResponseStageFileDownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessResponseStageFileDownload(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespStageFileDownloadParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessResponsePayloadPowerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessResponsePayloadPowerControl() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessResponsePayloadPowerControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessResponsePayloadPowerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespPayloadPowerControlParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessReqPayloadMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessReqPayloadMetrics() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ReqPayloadMetricsParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ReqPayloadMetricsParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessReqPayloadMetrics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessReqPayloadMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessReqPayloadMetrics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ReqPayloadMetricsParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessRespGnssEphStopDataReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessRespGnssEphStopDataReq() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespGnssEphStopDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespGnssEphStopDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessRespGnssEphStopDataReq(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessRespGnssEphStopDataReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessRespGnssEphStopDataReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGnssEphStopDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessRespGnssEphStopDataReq(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespGnssEphStopDataReq,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessRespGnssEphStartDataReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessRespGnssEphStartDataReq() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespGnssEphStartDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespGnssEphStartDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessRespGnssEphStartDataReq(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessRespGnssEphStartDataReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessRespGnssEphStartDataReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGnssEphStartDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessRespGnssEphStartDataReq(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespGnssEphStartDataReq,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessGnssEphData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessGnssEphData() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::GnssEphData, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::GnssEphData, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessGnssEphData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessGnssEphData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessGnssEphData(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::GnssEphData* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessGnssEphData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::GnssEphData,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessRespGetEpsVoltageStopReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessRespGetEpsVoltageStopReq() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessRespGetEpsVoltageStopReq(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessRespGetEpsVoltageStopReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessRespGetEpsVoltageStopReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessRespGetEpsVoltageStopReq(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespGetEpsVoltageStopReq,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessRespGetEpsVoltageStartReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessRespGetEpsVoltageStartReq() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessRespGetEpsVoltageStartReq(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessRespGetEpsVoltageStartReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessRespGetEpsVoltageStartReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessRespGetEpsVoltageStartReq(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespGetEpsVoltageStartReq,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessGetEpsVoltage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessGetEpsVoltage() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::GetEpsVoltage, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::GetEpsVoltage, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessGetEpsVoltage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessGetEpsVoltage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessGetEpsVoltage(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::GetEpsVoltage* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessGetEpsVoltage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::GetEpsVoltage,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessRespStartSesThermMgmntReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessRespStartSesThermMgmntReq() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessRespStartSesThermMgmntReq(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessRespStartSesThermMgmntReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessRespStartSesThermMgmntReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessRespStartSesThermMgmntReq(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespStartSesThermMgmntReq,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessRespStopSesThermMgmntReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessRespStopSesThermMgmntReq() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessRespStopSesThermMgmntReq(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessRespStopSesThermMgmntReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessRespStopSesThermMgmntReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessRespStopSesThermMgmntReq(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespStopSesThermMgmntReq,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessRespSesTempReq : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessRespSesTempReq() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespSesTempReqParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespSesTempReqParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessRespSesTempReq(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessRespSesTempReq() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessRespSesTempReq(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespSesTempReqParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessRespSesTempReq(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespSesTempReqParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessSesThrmlNtf : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessSesThrmlNtf() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::SesThermalStatusNtf, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::SesThermalStatusNtf, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessSesThrmlNtf(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessSesThrmlNtf() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessSesThrmlNtf(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::SesThermalStatusNtf* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessSesThrmlNtf(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::SesThermalStatusNtf,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessRespPaSatOsMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessRespPaSatOsMsg() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespPaSatOsMsg, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespPaSatOsMsg, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessRespPaSatOsMsg(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessRespPaSatOsMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessRespPaSatOsMsg(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPaSatOsMsg* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessRespPaSatOsMsg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespPaSatOsMsg,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_PA_StartSequence<WithStreamedUnaryMethod_PA_ShutdownApp<WithStreamedUnaryMethod_PA_ProcessHealthCheck<WithStreamedUnaryMethod_PA_ProcessResponseRegister<WithStreamedUnaryMethod_PA_ProcessResponseGetCurrentLocation<WithStreamedUnaryMethod_PA_ProcessResponseStageFileDownload<WithStreamedUnaryMethod_PA_ProcessResponsePayloadPowerControl<WithStreamedUnaryMethod_PA_ProcessReqPayloadMetrics<WithStreamedUnaryMethod_PA_ProcessRespGnssEphStopDataReq<WithStreamedUnaryMethod_PA_ProcessRespGnssEphStartDataReq<WithStreamedUnaryMethod_PA_ProcessGnssEphData<WithStreamedUnaryMethod_PA_ProcessRespGetEpsVoltageStopReq<WithStreamedUnaryMethod_PA_ProcessRespGetEpsVoltageStartReq<WithStreamedUnaryMethod_PA_ProcessGetEpsVoltage<WithStreamedUnaryMethod_PA_ProcessRespStartSesThermMgmntReq<WithStreamedUnaryMethod_PA_ProcessRespStopSesThermMgmntReq<WithStreamedUnaryMethod_PA_ProcessRespSesTempReq<WithStreamedUnaryMethod_PA_ProcessSesThrmlNtf<WithStreamedUnaryMethod_PA_ProcessRespPaSatOsMsg<Service > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_PA_StartSequence<WithStreamedUnaryMethod_PA_ShutdownApp<WithStreamedUnaryMethod_PA_ProcessHealthCheck<WithStreamedUnaryMethod_PA_ProcessResponseRegister<WithStreamedUnaryMethod_PA_ProcessResponseGetCurrentLocation<WithStreamedUnaryMethod_PA_ProcessResponseStageFileDownload<WithStreamedUnaryMethod_PA_ProcessResponsePayloadPowerControl<WithStreamedUnaryMethod_PA_ProcessReqPayloadMetrics<WithStreamedUnaryMethod_PA_ProcessRespGnssEphStopDataReq<WithStreamedUnaryMethod_PA_ProcessRespGnssEphStartDataReq<WithStreamedUnaryMethod_PA_ProcessGnssEphData<WithStreamedUnaryMethod_PA_ProcessRespGetEpsVoltageStopReq<WithStreamedUnaryMethod_PA_ProcessRespGetEpsVoltageStartReq<WithStreamedUnaryMethod_PA_ProcessGetEpsVoltage<WithStreamedUnaryMethod_PA_ProcessRespStartSesThermMgmntReq<WithStreamedUnaryMethod_PA_ProcessRespStopSesThermMgmntReq<WithStreamedUnaryMethod_PA_ProcessRespSesTempReq<WithStreamedUnaryMethod_PA_ProcessSesThrmlNtf<WithStreamedUnaryMethod_PA_ProcessRespPaSatOsMsg<Service > > > > > > > > > > > > > > > > > > > StreamedService;
};

class AntarisapiPayloadController final {
 public:
  static constexpr char const* service_full_name() {
    return "antaris_api_peer_to_peer.AntarisapiPayloadController";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status PC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_registerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_registerRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_get_current_locationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_get_current_locationRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_stage_file_downloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_stage_file_downloadRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_sequence_doneRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_sequence_doneRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_payload_power_controlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_payload_power_controlRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_response_health_checkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_response_health_checkRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_response_shutdownRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_response_shutdownRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_response_payload_metricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_response_payload_metricsRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_gnss_eph_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_gnss_eph_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_gnss_eph_stop_reqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_gnss_eph_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_gnss_eph_stop_reqRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_gnss_eph_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_gnss_eph_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_gnss_eph_start_reqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_gnss_eph_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_gnss_eph_start_reqRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_get_eps_voltage_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_get_eps_voltage_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_get_eps_voltage_stop_reqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_get_eps_voltage_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_get_eps_voltage_stop_reqRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_get_eps_voltage_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_get_eps_voltage_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_get_eps_voltage_start_reqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_get_eps_voltage_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_get_eps_voltage_start_reqRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_start_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_start_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_start_ses_therm_mgmnt_reqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_start_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_start_ses_therm_mgmnt_reqRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_stop_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_stop_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_stop_ses_therm_mgmnt_reqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_stop_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_stop_ses_therm_mgmnt_reqRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_ses_temp_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesTempReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_ses_temp_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesTempReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_ses_temp_reqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_ses_temp_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesTempReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_ses_temp_reqRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_pa_satos_message(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_pa_satos_message(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_pa_satos_messageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_pa_satos_message(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_pa_satos_messageRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void PC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_gnss_eph_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_gnss_eph_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_gnss_eph_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_gnss_eph_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_get_eps_voltage_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_get_eps_voltage_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_get_eps_voltage_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_get_eps_voltage_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_start_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_start_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_stop_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_stop_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_ses_temp_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesTempReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_ses_temp_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesTempReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_pa_satos_message(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_pa_satos_message(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_registerRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_registerRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_get_current_locationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_get_current_locationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_stage_file_downloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_stage_file_downloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_sequence_doneRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_sequence_doneRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_payload_power_controlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_payload_power_controlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_response_health_checkRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_response_health_checkRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_response_shutdownRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_response_shutdownRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_response_payload_metricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_response_payload_metricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_gnss_eph_stop_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_gnss_eph_stop_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_gnss_eph_start_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_gnss_eph_start_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_get_eps_voltage_stop_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_get_eps_voltage_stop_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_get_eps_voltage_start_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_get_eps_voltage_start_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_start_ses_therm_mgmnt_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_start_ses_therm_mgmnt_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_stop_ses_therm_mgmnt_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_stop_ses_therm_mgmnt_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_ses_temp_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesTempReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_ses_temp_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesTempReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_pa_satos_messageRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_pa_satos_messageRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status PC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_registerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_registerRaw(context, request, cq));
    }
    ::grpc::Status PC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_get_current_locationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_get_current_locationRaw(context, request, cq));
    }
    ::grpc::Status PC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_stage_file_downloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_stage_file_downloadRaw(context, request, cq));
    }
    ::grpc::Status PC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_sequence_doneRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_sequence_doneRaw(context, request, cq));
    }
    ::grpc::Status PC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_payload_power_controlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_payload_power_controlRaw(context, request, cq));
    }
    ::grpc::Status PC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_response_health_checkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_response_health_checkRaw(context, request, cq));
    }
    ::grpc::Status PC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_response_shutdownRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_response_shutdownRaw(context, request, cq));
    }
    ::grpc::Status PC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_response_payload_metricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_response_payload_metricsRaw(context, request, cq));
    }
    ::grpc::Status PC_gnss_eph_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_gnss_eph_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_gnss_eph_stop_reqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_gnss_eph_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_gnss_eph_stop_reqRaw(context, request, cq));
    }
    ::grpc::Status PC_gnss_eph_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_gnss_eph_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_gnss_eph_start_reqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_gnss_eph_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_gnss_eph_start_reqRaw(context, request, cq));
    }
    ::grpc::Status PC_get_eps_voltage_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_get_eps_voltage_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_get_eps_voltage_stop_reqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_get_eps_voltage_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_get_eps_voltage_stop_reqRaw(context, request, cq));
    }
    ::grpc::Status PC_get_eps_voltage_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_get_eps_voltage_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_get_eps_voltage_start_reqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_get_eps_voltage_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_get_eps_voltage_start_reqRaw(context, request, cq));
    }
    ::grpc::Status PC_start_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_start_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_start_ses_therm_mgmnt_reqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_start_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_start_ses_therm_mgmnt_reqRaw(context, request, cq));
    }
    ::grpc::Status PC_stop_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_stop_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_stop_ses_therm_mgmnt_reqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_stop_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_stop_ses_therm_mgmnt_reqRaw(context, request, cq));
    }
    ::grpc::Status PC_ses_temp_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesTempReq& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_ses_temp_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesTempReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_ses_temp_reqRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_ses_temp_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesTempReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_ses_temp_reqRaw(context, request, cq));
    }
    ::grpc::Status PC_pa_satos_message(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_pa_satos_message(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_pa_satos_messageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_pa_satos_message(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_pa_satos_messageRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void PC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_gnss_eph_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_gnss_eph_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_gnss_eph_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_gnss_eph_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_get_eps_voltage_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_get_eps_voltage_stop_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_get_eps_voltage_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_get_eps_voltage_start_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_start_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_start_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_stop_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_stop_ses_therm_mgmnt_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_ses_temp_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesTempReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_ses_temp_req(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesTempReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_pa_satos_message(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_pa_satos_message(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_registerRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_registerRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_get_current_locationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_get_current_locationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_stage_file_downloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_stage_file_downloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_sequence_doneRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_sequence_doneRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_payload_power_controlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_payload_power_controlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_response_health_checkRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_response_health_checkRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_response_shutdownRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_response_shutdownRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_response_payload_metricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_response_payload_metricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_gnss_eph_stop_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_gnss_eph_stop_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_gnss_eph_start_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_gnss_eph_start_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_get_eps_voltage_stop_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_get_eps_voltage_stop_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_get_eps_voltage_start_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_get_eps_voltage_start_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_start_ses_therm_mgmnt_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_start_ses_therm_mgmnt_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_stop_ses_therm_mgmnt_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_stop_ses_therm_mgmnt_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_ses_temp_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesTempReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_ses_temp_reqRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::SesTempReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_pa_satos_messageRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_pa_satos_messageRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_PC_register_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_get_current_location_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_stage_file_download_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_sequence_done_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_payload_power_control_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_response_health_check_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_response_shutdown_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_response_payload_metrics_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_gnss_eph_stop_req_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_gnss_eph_start_req_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_get_eps_voltage_stop_req_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_get_eps_voltage_start_req_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_start_ses_therm_mgmnt_req_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_stop_ses_therm_mgmnt_req_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_ses_temp_req_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_pa_satos_message_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status PC_register(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_get_current_location(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_stage_file_download(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_sequence_done(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_payload_power_control(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_response_health_check(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_response_shutdown(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_response_payload_metrics(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_gnss_eph_stop_req(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_gnss_eph_start_req(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_get_eps_voltage_stop_req(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_get_eps_voltage_start_req(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_start_ses_therm_mgmnt_req(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_stop_ses_therm_mgmnt_req(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_ses_temp_req(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::SesTempReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_pa_satos_message(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_register() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_PC_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_register(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_register(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ReqRegisterParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_get_current_location : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_get_current_location() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_PC_get_current_location() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_current_location(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_get_current_location(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_stage_file_download : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_stage_file_download() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_PC_stage_file_download() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_stage_file_download(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_stage_file_download(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_sequence_done : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_sequence_done() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_PC_sequence_done() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_sequence_done(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_sequence_done(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::CmdSequenceDoneParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_payload_power_control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_payload_power_control() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_PC_payload_power_control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_payload_power_control(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_payload_power_control(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_response_health_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_response_health_check() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_PC_response_health_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_health_check(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespHealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_response_health_check(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespHealthCheckParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_response_shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_response_shutdown() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_PC_response_shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_shutdown(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_response_shutdown(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespShutdownParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_response_payload_metrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_response_payload_metrics() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_PC_response_payload_metrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_payload_metrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_response_payload_metrics(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::PayloadMetricsResponse* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_gnss_eph_stop_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_gnss_eph_stop_req() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_PC_gnss_eph_stop_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_gnss_eph_stop_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_gnss_eph_stop_req(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_gnss_eph_start_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_gnss_eph_start_req() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_PC_gnss_eph_start_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_gnss_eph_start_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_gnss_eph_start_req(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_get_eps_voltage_stop_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_get_eps_voltage_stop_req() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_PC_get_eps_voltage_stop_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_eps_voltage_stop_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_get_eps_voltage_stop_req(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_get_eps_voltage_start_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_get_eps_voltage_start_req() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_PC_get_eps_voltage_start_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_eps_voltage_start_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_get_eps_voltage_start_req(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_start_ses_therm_mgmnt_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_start_ses_therm_mgmnt_req() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_PC_start_ses_therm_mgmnt_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_start_ses_therm_mgmnt_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_start_ses_therm_mgmnt_req(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::StartSesThermMgmntReq* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_stop_ses_therm_mgmnt_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_stop_ses_therm_mgmnt_req() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_PC_stop_ses_therm_mgmnt_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_stop_ses_therm_mgmnt_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_stop_ses_therm_mgmnt_req(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::StopSesThermMgmntReq* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_ses_temp_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_ses_temp_req() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_PC_ses_temp_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_ses_temp_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::SesTempReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_ses_temp_req(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::SesTempReq* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_pa_satos_message : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_pa_satos_message() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_PC_pa_satos_message() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_pa_satos_message(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PaSatOsMsg* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_pa_satos_message(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::PaSatOsMsg* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_PC_register<WithAsyncMethod_PC_get_current_location<WithAsyncMethod_PC_stage_file_download<WithAsyncMethod_PC_sequence_done<WithAsyncMethod_PC_payload_power_control<WithAsyncMethod_PC_response_health_check<WithAsyncMethod_PC_response_shutdown<WithAsyncMethod_PC_response_payload_metrics<WithAsyncMethod_PC_gnss_eph_stop_req<WithAsyncMethod_PC_gnss_eph_start_req<WithAsyncMethod_PC_get_eps_voltage_stop_req<WithAsyncMethod_PC_get_eps_voltage_start_req<WithAsyncMethod_PC_start_ses_therm_mgmnt_req<WithAsyncMethod_PC_stop_ses_therm_mgmnt_req<WithAsyncMethod_PC_ses_temp_req<WithAsyncMethod_PC_pa_satos_message<Service > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_PC_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_register() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_register(context, request, response); }));}
    void SetMessageAllocatorFor_PC_register(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ReqRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_register(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_register(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_get_current_location : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_get_current_location() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_get_current_location(context, request, response); }));}
    void SetMessageAllocatorFor_PC_get_current_location(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_get_current_location() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_current_location(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_get_current_location(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_stage_file_download : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_stage_file_download() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_stage_file_download(context, request, response); }));}
    void SetMessageAllocatorFor_PC_stage_file_download(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ReqStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_stage_file_download() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_stage_file_download(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_stage_file_download(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_sequence_done : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_sequence_done() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::CmdSequenceDoneParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_sequence_done(context, request, response); }));}
    void SetMessageAllocatorFor_PC_sequence_done(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::CmdSequenceDoneParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::CmdSequenceDoneParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_sequence_done() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_sequence_done(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_sequence_done(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_payload_power_control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_payload_power_control() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_payload_power_control(context, request, response); }));}
    void SetMessageAllocatorFor_PC_payload_power_control(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_payload_power_control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_payload_power_control(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_payload_power_control(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_response_health_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_response_health_check() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespHealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_response_health_check(context, request, response); }));}
    void SetMessageAllocatorFor_PC_response_health_check(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespHealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespHealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_response_health_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_health_check(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespHealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_response_health_check(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespHealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_response_shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_response_shutdown() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_response_shutdown(context, request, response); }));}
    void SetMessageAllocatorFor_PC_response_shutdown(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_response_shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_shutdown(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_response_shutdown(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_response_payload_metrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_response_payload_metrics() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::PayloadMetricsResponse, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_response_payload_metrics(context, request, response); }));}
    void SetMessageAllocatorFor_PC_response_payload_metrics(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::PayloadMetricsResponse, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::PayloadMetricsResponse, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_response_payload_metrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_payload_metrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_response_payload_metrics(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_gnss_eph_stop_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_gnss_eph_stop_req() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_gnss_eph_stop_req(context, request, response); }));}
    void SetMessageAllocatorFor_PC_gnss_eph_stop_req(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_gnss_eph_stop_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_gnss_eph_stop_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_gnss_eph_stop_req(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_gnss_eph_start_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_gnss_eph_start_req() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_gnss_eph_start_req(context, request, response); }));}
    void SetMessageAllocatorFor_PC_gnss_eph_start_req(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_gnss_eph_start_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_gnss_eph_start_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_gnss_eph_start_req(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_get_eps_voltage_stop_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_get_eps_voltage_stop_req() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_get_eps_voltage_stop_req(context, request, response); }));}
    void SetMessageAllocatorFor_PC_get_eps_voltage_stop_req(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_get_eps_voltage_stop_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_eps_voltage_stop_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_get_eps_voltage_stop_req(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_get_eps_voltage_start_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_get_eps_voltage_start_req() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_get_eps_voltage_start_req(context, request, response); }));}
    void SetMessageAllocatorFor_PC_get_eps_voltage_start_req(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_get_eps_voltage_start_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_eps_voltage_start_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_get_eps_voltage_start_req(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_start_ses_therm_mgmnt_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_start_ses_therm_mgmnt_req() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::StartSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_start_ses_therm_mgmnt_req(context, request, response); }));}
    void SetMessageAllocatorFor_PC_start_ses_therm_mgmnt_req(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::StartSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::StartSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_start_ses_therm_mgmnt_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_start_ses_therm_mgmnt_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_start_ses_therm_mgmnt_req(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_stop_ses_therm_mgmnt_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_stop_ses_therm_mgmnt_req() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::StopSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_stop_ses_therm_mgmnt_req(context, request, response); }));}
    void SetMessageAllocatorFor_PC_stop_ses_therm_mgmnt_req(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::StopSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::StopSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_stop_ses_therm_mgmnt_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_stop_ses_therm_mgmnt_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_stop_ses_therm_mgmnt_req(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_ses_temp_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_ses_temp_req() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::SesTempReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::SesTempReq* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_ses_temp_req(context, request, response); }));}
    void SetMessageAllocatorFor_PC_ses_temp_req(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::SesTempReq, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::SesTempReq, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_ses_temp_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_ses_temp_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::SesTempReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_ses_temp_req(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::SesTempReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_pa_satos_message : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_pa_satos_message() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::PaSatOsMsg, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::PaSatOsMsg* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_pa_satos_message(context, request, response); }));}
    void SetMessageAllocatorFor_PC_pa_satos_message(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::PaSatOsMsg, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::PaSatOsMsg, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_pa_satos_message() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_pa_satos_message(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PaSatOsMsg* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_pa_satos_message(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::PaSatOsMsg* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_PC_register<WithCallbackMethod_PC_get_current_location<WithCallbackMethod_PC_stage_file_download<WithCallbackMethod_PC_sequence_done<WithCallbackMethod_PC_payload_power_control<WithCallbackMethod_PC_response_health_check<WithCallbackMethod_PC_response_shutdown<WithCallbackMethod_PC_response_payload_metrics<WithCallbackMethod_PC_gnss_eph_stop_req<WithCallbackMethod_PC_gnss_eph_start_req<WithCallbackMethod_PC_get_eps_voltage_stop_req<WithCallbackMethod_PC_get_eps_voltage_start_req<WithCallbackMethod_PC_start_ses_therm_mgmnt_req<WithCallbackMethod_PC_stop_ses_therm_mgmnt_req<WithCallbackMethod_PC_ses_temp_req<WithCallbackMethod_PC_pa_satos_message<Service > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_PC_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_register() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_PC_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_register(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_get_current_location : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_get_current_location() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_PC_get_current_location() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_current_location(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_stage_file_download : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_stage_file_download() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_PC_stage_file_download() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_stage_file_download(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_sequence_done : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_sequence_done() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_PC_sequence_done() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_sequence_done(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_payload_power_control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_payload_power_control() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_PC_payload_power_control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_payload_power_control(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_response_health_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_response_health_check() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_PC_response_health_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_health_check(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespHealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_response_shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_response_shutdown() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_PC_response_shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_shutdown(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_response_payload_metrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_response_payload_metrics() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_PC_response_payload_metrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_payload_metrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_gnss_eph_stop_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_gnss_eph_stop_req() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_PC_gnss_eph_stop_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_gnss_eph_stop_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_gnss_eph_start_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_gnss_eph_start_req() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_PC_gnss_eph_start_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_gnss_eph_start_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_get_eps_voltage_stop_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_get_eps_voltage_stop_req() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_PC_get_eps_voltage_stop_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_eps_voltage_stop_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_get_eps_voltage_start_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_get_eps_voltage_start_req() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_PC_get_eps_voltage_start_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_eps_voltage_start_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_start_ses_therm_mgmnt_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_start_ses_therm_mgmnt_req() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_PC_start_ses_therm_mgmnt_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_start_ses_therm_mgmnt_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_stop_ses_therm_mgmnt_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_stop_ses_therm_mgmnt_req() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_PC_stop_ses_therm_mgmnt_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_stop_ses_therm_mgmnt_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_ses_temp_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_ses_temp_req() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_PC_ses_temp_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_ses_temp_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::SesTempReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_pa_satos_message : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_pa_satos_message() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_PC_pa_satos_message() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_pa_satos_message(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PaSatOsMsg* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_register() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_PC_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_register(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_register(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_get_current_location : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_get_current_location() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_PC_get_current_location() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_current_location(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_get_current_location(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_stage_file_download : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_stage_file_download() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_PC_stage_file_download() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_stage_file_download(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_stage_file_download(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_sequence_done : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_sequence_done() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_PC_sequence_done() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_sequence_done(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_sequence_done(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_payload_power_control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_payload_power_control() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_PC_payload_power_control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_payload_power_control(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_payload_power_control(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_response_health_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_response_health_check() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_PC_response_health_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_health_check(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespHealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_response_health_check(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_response_shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_response_shutdown() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_PC_response_shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_shutdown(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_response_shutdown(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_response_payload_metrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_response_payload_metrics() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_PC_response_payload_metrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_payload_metrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_response_payload_metrics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_gnss_eph_stop_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_gnss_eph_stop_req() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_PC_gnss_eph_stop_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_gnss_eph_stop_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_gnss_eph_stop_req(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_gnss_eph_start_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_gnss_eph_start_req() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_PC_gnss_eph_start_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_gnss_eph_start_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_gnss_eph_start_req(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_get_eps_voltage_stop_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_get_eps_voltage_stop_req() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_PC_get_eps_voltage_stop_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_eps_voltage_stop_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_get_eps_voltage_stop_req(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_get_eps_voltage_start_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_get_eps_voltage_start_req() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_PC_get_eps_voltage_start_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_eps_voltage_start_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_get_eps_voltage_start_req(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_start_ses_therm_mgmnt_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_start_ses_therm_mgmnt_req() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_PC_start_ses_therm_mgmnt_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_start_ses_therm_mgmnt_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_start_ses_therm_mgmnt_req(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_stop_ses_therm_mgmnt_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_stop_ses_therm_mgmnt_req() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_PC_stop_ses_therm_mgmnt_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_stop_ses_therm_mgmnt_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_stop_ses_therm_mgmnt_req(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_ses_temp_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_ses_temp_req() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_PC_ses_temp_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_ses_temp_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::SesTempReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_ses_temp_req(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_pa_satos_message : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_pa_satos_message() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_PC_pa_satos_message() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_pa_satos_message(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PaSatOsMsg* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_pa_satos_message(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_register() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_register(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_register(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_register(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_get_current_location : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_get_current_location() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_get_current_location(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_get_current_location() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_current_location(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_get_current_location(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_stage_file_download : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_stage_file_download() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_stage_file_download(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_stage_file_download() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_stage_file_download(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_stage_file_download(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_sequence_done : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_sequence_done() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_sequence_done(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_sequence_done() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_sequence_done(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_sequence_done(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_payload_power_control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_payload_power_control() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_payload_power_control(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_payload_power_control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_payload_power_control(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_payload_power_control(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_response_health_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_response_health_check() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_response_health_check(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_response_health_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_health_check(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespHealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_response_health_check(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_response_shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_response_shutdown() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_response_shutdown(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_response_shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_shutdown(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_response_shutdown(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_response_payload_metrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_response_payload_metrics() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_response_payload_metrics(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_response_payload_metrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_payload_metrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_response_payload_metrics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_gnss_eph_stop_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_gnss_eph_stop_req() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_gnss_eph_stop_req(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_gnss_eph_stop_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_gnss_eph_stop_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_gnss_eph_stop_req(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_gnss_eph_start_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_gnss_eph_start_req() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_gnss_eph_start_req(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_gnss_eph_start_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_gnss_eph_start_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_gnss_eph_start_req(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_get_eps_voltage_stop_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_get_eps_voltage_stop_req() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_get_eps_voltage_stop_req(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_get_eps_voltage_stop_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_eps_voltage_stop_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_get_eps_voltage_stop_req(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_get_eps_voltage_start_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_get_eps_voltage_start_req() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_get_eps_voltage_start_req(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_get_eps_voltage_start_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_eps_voltage_start_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_get_eps_voltage_start_req(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_start_ses_therm_mgmnt_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_start_ses_therm_mgmnt_req() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_start_ses_therm_mgmnt_req(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_start_ses_therm_mgmnt_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_start_ses_therm_mgmnt_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_start_ses_therm_mgmnt_req(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_stop_ses_therm_mgmnt_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_stop_ses_therm_mgmnt_req() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_stop_ses_therm_mgmnt_req(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_stop_ses_therm_mgmnt_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_stop_ses_therm_mgmnt_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_stop_ses_therm_mgmnt_req(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_ses_temp_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_ses_temp_req() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_ses_temp_req(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_ses_temp_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_ses_temp_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::SesTempReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_ses_temp_req(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_pa_satos_message : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_pa_satos_message() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_pa_satos_message(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_pa_satos_message() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_pa_satos_message(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PaSatOsMsg* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_pa_satos_message(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_register() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ReqRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ReqRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_register(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_register(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_register(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ReqRegisterParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_get_current_location : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_get_current_location() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_get_current_location(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_get_current_location() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_get_current_location(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_get_current_location(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_stage_file_download : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_stage_file_download() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ReqStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ReqStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_stage_file_download(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_stage_file_download() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_stage_file_download(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_stage_file_download(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ReqStageFileDownloadParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_sequence_done : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_sequence_done() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::CmdSequenceDoneParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::CmdSequenceDoneParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_sequence_done(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_sequence_done() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_sequence_done(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_sequence_done(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::CmdSequenceDoneParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_payload_power_control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_payload_power_control() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_payload_power_control(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_payload_power_control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_payload_power_control(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_payload_power_control(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_response_health_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_response_health_check() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespHealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespHealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_response_health_check(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_response_health_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_response_health_check(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespHealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_response_health_check(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespHealthCheckParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_response_shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_response_shutdown() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_response_shutdown(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_response_shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_response_shutdown(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_response_shutdown(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespShutdownParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_response_payload_metrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_response_payload_metrics() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::PayloadMetricsResponse, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::PayloadMetricsResponse, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_response_payload_metrics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_response_payload_metrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_response_payload_metrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_response_payload_metrics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::PayloadMetricsResponse,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_gnss_eph_stop_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_gnss_eph_stop_req() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_gnss_eph_stop_req(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_gnss_eph_stop_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_gnss_eph_stop_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_gnss_eph_stop_req(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ReqGnssEphStopDataReq,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_gnss_eph_start_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_gnss_eph_start_req() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_gnss_eph_start_req(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_gnss_eph_start_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_gnss_eph_start_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_gnss_eph_start_req(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ReqGnssEphStartDataReq,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_get_eps_voltage_stop_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_get_eps_voltage_stop_req() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_get_eps_voltage_stop_req(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_get_eps_voltage_stop_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_get_eps_voltage_stop_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_get_eps_voltage_stop_req(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ReqGetEpsVoltageStopReq,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_get_eps_voltage_start_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_get_eps_voltage_start_req() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_get_eps_voltage_start_req(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_get_eps_voltage_start_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_get_eps_voltage_start_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_get_eps_voltage_start_req(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ReqGetEpsVoltageStartReq,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_start_ses_therm_mgmnt_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_start_ses_therm_mgmnt_req() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::StartSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::StartSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_start_ses_therm_mgmnt_req(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_start_ses_therm_mgmnt_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_start_ses_therm_mgmnt_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_start_ses_therm_mgmnt_req(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::StartSesThermMgmntReq,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_stop_ses_therm_mgmnt_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_stop_ses_therm_mgmnt_req() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::StopSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::StopSesThermMgmntReq, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_stop_ses_therm_mgmnt_req(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_stop_ses_therm_mgmnt_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_stop_ses_therm_mgmnt_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StopSesThermMgmntReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_stop_ses_therm_mgmnt_req(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::StopSesThermMgmntReq,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_ses_temp_req : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_ses_temp_req() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::SesTempReq, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::SesTempReq, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_ses_temp_req(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_ses_temp_req() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_ses_temp_req(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::SesTempReq* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_ses_temp_req(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::SesTempReq,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_pa_satos_message : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_pa_satos_message() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::PaSatOsMsg, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::PaSatOsMsg, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_pa_satos_message(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_pa_satos_message() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_pa_satos_message(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PaSatOsMsg* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_pa_satos_message(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::PaSatOsMsg,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_PC_register<WithStreamedUnaryMethod_PC_get_current_location<WithStreamedUnaryMethod_PC_stage_file_download<WithStreamedUnaryMethod_PC_sequence_done<WithStreamedUnaryMethod_PC_payload_power_control<WithStreamedUnaryMethod_PC_response_health_check<WithStreamedUnaryMethod_PC_response_shutdown<WithStreamedUnaryMethod_PC_response_payload_metrics<WithStreamedUnaryMethod_PC_gnss_eph_stop_req<WithStreamedUnaryMethod_PC_gnss_eph_start_req<WithStreamedUnaryMethod_PC_get_eps_voltage_stop_req<WithStreamedUnaryMethod_PC_get_eps_voltage_start_req<WithStreamedUnaryMethod_PC_start_ses_therm_mgmnt_req<WithStreamedUnaryMethod_PC_stop_ses_therm_mgmnt_req<WithStreamedUnaryMethod_PC_ses_temp_req<WithStreamedUnaryMethod_PC_pa_satos_message<Service > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_PC_register<WithStreamedUnaryMethod_PC_get_current_location<WithStreamedUnaryMethod_PC_stage_file_download<WithStreamedUnaryMethod_PC_sequence_done<WithStreamedUnaryMethod_PC_payload_power_control<WithStreamedUnaryMethod_PC_response_health_check<WithStreamedUnaryMethod_PC_response_shutdown<WithStreamedUnaryMethod_PC_response_payload_metrics<WithStreamedUnaryMethod_PC_gnss_eph_stop_req<WithStreamedUnaryMethod_PC_gnss_eph_start_req<WithStreamedUnaryMethod_PC_get_eps_voltage_stop_req<WithStreamedUnaryMethod_PC_get_eps_voltage_start_req<WithStreamedUnaryMethod_PC_start_ses_therm_mgmnt_req<WithStreamedUnaryMethod_PC_stop_ses_therm_mgmnt_req<WithStreamedUnaryMethod_PC_ses_temp_req<WithStreamedUnaryMethod_PC_pa_satos_message<Service > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace antaris_api_peer_to_peer


#endif  // GRPC_defs_2fgen_2fproto_2fantaris_5fapi_2eproto__INCLUDED
