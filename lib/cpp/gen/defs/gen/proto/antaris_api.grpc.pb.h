// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: defs/gen/proto/antaris_api.proto
// Original file comments:
// //////////////////////////////////////////////////////////
//
//  
//
//  Copyright 2022 Antaris, Inc.
//
//  
//
//  Licensed under the Apache License, Version 2.0 (the 'License');
//
//  you may not use this file except in compliance with the License.
//
//  You may obtain a copy of the License at
//
//  
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  
//
//  Unless required by applicable law or agreed to in writing, software
//
//  distributed under the License is distributed on an 'AS IS' BASIS,
//
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
//  See the License for the specific language governing permissions and
//
//  limitations under the License.
//
//  
//
//  Copyright: Copyright 2022 Antaris, Inc.
//
//  This is an autogenerated file. Any changes made to this file would likely be over-written at build time.
//
//  Generated-From: antaris_api.xml
//
//
// //////////////////////////////////////////////////////////
//
#ifndef GRPC_defs_2fgen_2fproto_2fantaris_5fapi_2eproto__INCLUDED
#define GRPC_defs_2fgen_2fproto_2fantaris_5fapi_2eproto__INCLUDED

#include "defs/gen/proto/antaris_api.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace antaris_api_peer_to_peer {

class AntarisapiApplicationCallback final {
 public:
  static constexpr char const* service_full_name() {
    return "antaris_api_peer_to_peer.AntarisapiApplicationCallback";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status PA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_StartSequenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_StartSequenceRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ShutdownAppRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ShutdownAppRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessHealthCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessHealthCheckRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponseRegisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponseRegisterRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponseGetCurrentLocationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponseGetCurrentLocationRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponseStageFileDownloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponseStageFileDownloadRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponsePayloadPowerControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponsePayloadPowerControlRaw(context, request, cq));
    }
    virtual ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessReqPayloadMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessReqPayloadMetricsRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void PA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_StartSequenceRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_StartSequenceRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ShutdownAppRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ShutdownAppRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessHealthCheckRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessHealthCheckRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponseRegisterRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponseRegisterRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponseGetCurrentLocationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponseGetCurrentLocationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponseStageFileDownloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponseStageFileDownloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponsePayloadPowerControlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponsePayloadPowerControlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessReqPayloadMetricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessReqPayloadMetricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status PA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_StartSequenceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_StartSequenceRaw(context, request, cq));
    }
    ::grpc::Status PA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ShutdownAppRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ShutdownAppRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessHealthCheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessHealthCheckRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponseRegisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponseRegisterRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponseGetCurrentLocationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponseGetCurrentLocationRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponseStageFileDownloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponseStageFileDownloadRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessResponsePayloadPowerControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessResponsePayloadPowerControlRaw(context, request, cq));
    }
    ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPA_ProcessReqPayloadMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPA_ProcessReqPayloadMetricsRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void PA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_StartSequence(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ShutdownApp(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessHealthCheck(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessResponseRegister(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessResponseGetCurrentLocation(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessResponseStageFileDownload(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessResponsePayloadPowerControl(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PA_ProcessReqPayloadMetrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_StartSequenceRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_StartSequenceRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ShutdownAppRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ShutdownAppRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ShutdownParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessHealthCheckRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessHealthCheckRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponseRegisterRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponseRegisterRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponseGetCurrentLocationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponseGetCurrentLocationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponseStageFileDownloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponseStageFileDownloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessResponsePayloadPowerControlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessResponsePayloadPowerControlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPA_ProcessReqPayloadMetricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPA_ProcessReqPayloadMetricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_PA_StartSequence_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ShutdownApp_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessHealthCheck_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessResponseRegister_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessResponseGetCurrentLocation_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessResponseStageFileDownload_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessResponsePayloadPowerControl_;
    const ::grpc::internal::RpcMethod rpcmethod_PA_ProcessReqPayloadMetrics_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status PA_StartSequence(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ShutdownApp(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessHealthCheck(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessResponseRegister(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_StartSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_StartSequence() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_PA_StartSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_StartSequence(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSequenceParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_StartSequence(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::StartSequenceParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ShutdownApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ShutdownApp() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_PA_ShutdownApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ShutdownApp(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ShutdownApp(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ShutdownParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessHealthCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessHealthCheck() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_PA_ProcessHealthCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessHealthCheck(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::HealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessHealthCheck(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::HealthCheckParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessResponseRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessResponseRegister() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_PA_ProcessResponseRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseRegister(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponseRegister(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespRegisterParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessResponseGetCurrentLocation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessResponseGetCurrentLocation() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_PA_ProcessResponseGetCurrentLocation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessResponseStageFileDownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessResponseStageFileDownload() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_PA_ProcessResponseStageFileDownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponseStageFileDownload(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespStageFileDownloadParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessResponsePayloadPowerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessResponsePayloadPowerControl() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_PA_ProcessResponsePayloadPowerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PA_ProcessReqPayloadMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PA_ProcessReqPayloadMetrics() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_PA_ProcessReqPayloadMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessReqPayloadMetrics(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_PA_StartSequence<WithAsyncMethod_PA_ShutdownApp<WithAsyncMethod_PA_ProcessHealthCheck<WithAsyncMethod_PA_ProcessResponseRegister<WithAsyncMethod_PA_ProcessResponseGetCurrentLocation<WithAsyncMethod_PA_ProcessResponseStageFileDownload<WithAsyncMethod_PA_ProcessResponsePayloadPowerControl<WithAsyncMethod_PA_ProcessReqPayloadMetrics<Service > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_PA_StartSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_StartSequence() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::StartSequenceParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::StartSequenceParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_StartSequence(context, request, response); }));}
    void SetMessageAllocatorFor_PA_StartSequence(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::StartSequenceParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::StartSequenceParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_StartSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_StartSequence(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSequenceParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_StartSequence(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSequenceParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ShutdownApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ShutdownApp() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ShutdownApp(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ShutdownApp(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ShutdownApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ShutdownApp(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ShutdownApp(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessHealthCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessHealthCheck() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::HealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::HealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessHealthCheck(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessHealthCheck(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::HealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::HealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessHealthCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessHealthCheck(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::HealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessHealthCheck(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::HealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessResponseRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessResponseRegister() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessResponseRegister(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessResponseRegister(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessResponseRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseRegister(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponseRegister(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessResponseGetCurrentLocation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessResponseGetCurrentLocation() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessResponseGetCurrentLocation(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessResponseGetCurrentLocation(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessResponseGetCurrentLocation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponseGetCurrentLocation(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessResponseStageFileDownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessResponseStageFileDownload() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessResponseStageFileDownload(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessResponseStageFileDownload(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessResponseStageFileDownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponseStageFileDownload(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessResponsePayloadPowerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessResponsePayloadPowerControl() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessResponsePayloadPowerControl(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessResponsePayloadPowerControl(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessResponsePayloadPowerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponsePayloadPowerControl(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PA_ProcessReqPayloadMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PA_ProcessReqPayloadMetrics() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqPayloadMetricsParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PA_ProcessReqPayloadMetrics(context, request, response); }));}
    void SetMessageAllocatorFor_PA_ProcessReqPayloadMetrics(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ReqPayloadMetricsParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqPayloadMetricsParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PA_ProcessReqPayloadMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessReqPayloadMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_PA_StartSequence<WithCallbackMethod_PA_ShutdownApp<WithCallbackMethod_PA_ProcessHealthCheck<WithCallbackMethod_PA_ProcessResponseRegister<WithCallbackMethod_PA_ProcessResponseGetCurrentLocation<WithCallbackMethod_PA_ProcessResponseStageFileDownload<WithCallbackMethod_PA_ProcessResponsePayloadPowerControl<WithCallbackMethod_PA_ProcessReqPayloadMetrics<Service > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_PA_StartSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_StartSequence() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_PA_StartSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_StartSequence(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSequenceParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ShutdownApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ShutdownApp() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_PA_ShutdownApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ShutdownApp(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessHealthCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessHealthCheck() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_PA_ProcessHealthCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessHealthCheck(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::HealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessResponseRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessResponseRegister() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_PA_ProcessResponseRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseRegister(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessResponseGetCurrentLocation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessResponseGetCurrentLocation() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_PA_ProcessResponseGetCurrentLocation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessResponseStageFileDownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessResponseStageFileDownload() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_PA_ProcessResponseStageFileDownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessResponsePayloadPowerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessResponsePayloadPowerControl() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_PA_ProcessResponsePayloadPowerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PA_ProcessReqPayloadMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PA_ProcessReqPayloadMetrics() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_PA_ProcessReqPayloadMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_StartSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_StartSequence() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_PA_StartSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_StartSequence(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSequenceParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_StartSequence(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ShutdownApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ShutdownApp() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_PA_ShutdownApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ShutdownApp(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ShutdownApp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessHealthCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessHealthCheck() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_PA_ProcessHealthCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessHealthCheck(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::HealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessHealthCheck(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessResponseRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessResponseRegister() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_PA_ProcessResponseRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseRegister(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponseRegister(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessResponseGetCurrentLocation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessResponseGetCurrentLocation() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_PA_ProcessResponseGetCurrentLocation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessResponseStageFileDownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessResponseStageFileDownload() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_PA_ProcessResponseStageFileDownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponseStageFileDownload(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessResponsePayloadPowerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessResponsePayloadPowerControl() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_PA_ProcessResponsePayloadPowerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PA_ProcessReqPayloadMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PA_ProcessReqPayloadMetrics() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_PA_ProcessReqPayloadMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPA_ProcessReqPayloadMetrics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_StartSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_StartSequence() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_StartSequence(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_StartSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_StartSequence(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSequenceParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_StartSequence(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ShutdownApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ShutdownApp() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ShutdownApp(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ShutdownApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ShutdownApp(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ShutdownApp(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessHealthCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessHealthCheck() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessHealthCheck(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessHealthCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessHealthCheck(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::HealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessHealthCheck(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessResponseRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessResponseRegister() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessResponseRegister(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessResponseRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseRegister(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponseRegister(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessResponseGetCurrentLocation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessResponseGetCurrentLocation() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessResponseGetCurrentLocation(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessResponseGetCurrentLocation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponseGetCurrentLocation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessResponseStageFileDownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessResponseStageFileDownload() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessResponseStageFileDownload(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessResponseStageFileDownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponseStageFileDownload(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessResponsePayloadPowerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessResponsePayloadPowerControl() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessResponsePayloadPowerControl(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessResponsePayloadPowerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessResponsePayloadPowerControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PA_ProcessReqPayloadMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PA_ProcessReqPayloadMetrics() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PA_ProcessReqPayloadMetrics(context, request, response); }));
    }
    ~WithRawCallbackMethod_PA_ProcessReqPayloadMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PA_ProcessReqPayloadMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_StartSequence : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_StartSequence() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::StartSequenceParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::StartSequenceParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_StartSequence(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_StartSequence() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_StartSequence(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::StartSequenceParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_StartSequence(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::StartSequenceParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ShutdownApp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ShutdownApp() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ShutdownApp(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ShutdownApp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ShutdownApp(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ShutdownApp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ShutdownParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessHealthCheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessHealthCheck() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::HealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::HealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessHealthCheck(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessHealthCheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessHealthCheck(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::HealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessHealthCheck(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::HealthCheckParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessResponseRegister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessResponseRegister() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessResponseRegister(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessResponseRegister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessResponseRegister(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessResponseRegister(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespRegisterParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessResponseGetCurrentLocation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessResponseGetCurrentLocation() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessResponseGetCurrentLocation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessResponseGetCurrentLocation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessResponseGetCurrentLocation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespGetCurrentLocationParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessResponseStageFileDownload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessResponseStageFileDownload() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessResponseStageFileDownload(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessResponseStageFileDownload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessResponseStageFileDownload(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessResponseStageFileDownload(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespStageFileDownloadParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessResponsePayloadPowerControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessResponsePayloadPowerControl() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessResponsePayloadPowerControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessResponsePayloadPowerControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessResponsePayloadPowerControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespPayloadPowerControlParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PA_ProcessReqPayloadMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PA_ProcessReqPayloadMetrics() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ReqPayloadMetricsParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ReqPayloadMetricsParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPA_ProcessReqPayloadMetrics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PA_ProcessReqPayloadMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PA_ProcessReqPayloadMetrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadMetricsParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPA_ProcessReqPayloadMetrics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ReqPayloadMetricsParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_PA_StartSequence<WithStreamedUnaryMethod_PA_ShutdownApp<WithStreamedUnaryMethod_PA_ProcessHealthCheck<WithStreamedUnaryMethod_PA_ProcessResponseRegister<WithStreamedUnaryMethod_PA_ProcessResponseGetCurrentLocation<WithStreamedUnaryMethod_PA_ProcessResponseStageFileDownload<WithStreamedUnaryMethod_PA_ProcessResponsePayloadPowerControl<WithStreamedUnaryMethod_PA_ProcessReqPayloadMetrics<Service > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_PA_StartSequence<WithStreamedUnaryMethod_PA_ShutdownApp<WithStreamedUnaryMethod_PA_ProcessHealthCheck<WithStreamedUnaryMethod_PA_ProcessResponseRegister<WithStreamedUnaryMethod_PA_ProcessResponseGetCurrentLocation<WithStreamedUnaryMethod_PA_ProcessResponseStageFileDownload<WithStreamedUnaryMethod_PA_ProcessResponsePayloadPowerControl<WithStreamedUnaryMethod_PA_ProcessReqPayloadMetrics<Service > > > > > > > > StreamedService;
};

class AntarisapiPayloadController final {
 public:
  static constexpr char const* service_full_name() {
    return "antaris_api_peer_to_peer.AntarisapiPayloadController";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status PC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_registerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_registerRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_get_current_locationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_get_current_locationRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_stage_file_downloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_stage_file_downloadRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_sequence_doneRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_sequence_doneRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_payload_power_controlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_payload_power_controlRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_response_health_checkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_response_health_checkRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_response_shutdownRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_response_shutdownRaw(context, request, cq));
    }
    virtual ::grpc::Status PC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_response_payload_metricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_response_payload_metricsRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void PC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_registerRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_registerRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_get_current_locationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_get_current_locationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_stage_file_downloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_stage_file_downloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_sequence_doneRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_sequence_doneRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_payload_power_controlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_payload_power_controlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_response_health_checkRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_response_health_checkRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_response_shutdownRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_response_shutdownRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_response_payload_metricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_response_payload_metricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status PC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_registerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_registerRaw(context, request, cq));
    }
    ::grpc::Status PC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_get_current_locationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_get_current_locationRaw(context, request, cq));
    }
    ::grpc::Status PC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_stage_file_downloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_stage_file_downloadRaw(context, request, cq));
    }
    ::grpc::Status PC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_sequence_doneRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_sequence_doneRaw(context, request, cq));
    }
    ::grpc::Status PC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_payload_power_controlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_payload_power_controlRaw(context, request, cq));
    }
    ::grpc::Status PC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_response_health_checkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_response_health_checkRaw(context, request, cq));
    }
    ::grpc::Status PC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_response_shutdownRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_response_shutdownRaw(context, request, cq));
    }
    ::grpc::Status PC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::antaris_api_peer_to_peer::AntarisReturnType* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> AsyncPC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(AsyncPC_response_payload_metricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>> PrepareAsyncPC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>>(PrepareAsyncPC_response_payload_metricsRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void PC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_register(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_get_current_location(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_stage_file_download(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_sequence_done(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_payload_power_control(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_response_health_check(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_response_shutdown(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, std::function<void(::grpc::Status)>) override;
      void PC_response_payload_metrics(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* request, ::antaris_api_peer_to_peer::AntarisReturnType* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_registerRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_registerRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_get_current_locationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_get_current_locationRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_stage_file_downloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_stage_file_downloadRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_sequence_doneRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_sequence_doneRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_payload_power_controlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_payload_power_controlRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_response_health_checkRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_response_health_checkRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_response_shutdownRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_response_shutdownRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* AsyncPC_response_payload_metricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::antaris_api_peer_to_peer::AntarisReturnType>* PrepareAsyncPC_response_payload_metricsRaw(::grpc::ClientContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_PC_register_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_get_current_location_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_stage_file_download_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_sequence_done_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_payload_power_control_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_response_health_check_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_response_shutdown_;
    const ::grpc::internal::RpcMethod rpcmethod_PC_response_payload_metrics_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status PC_register(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_get_current_location(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_stage_file_download(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_sequence_done(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_payload_power_control(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_response_health_check(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_response_shutdown(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
    virtual ::grpc::Status PC_response_payload_metrics(::grpc::ServerContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* request, ::antaris_api_peer_to_peer::AntarisReturnType* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_register() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_PC_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_register(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_register(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ReqRegisterParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_get_current_location : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_get_current_location() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_PC_get_current_location() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_current_location(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_get_current_location(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_stage_file_download : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_stage_file_download() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_PC_stage_file_download() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_stage_file_download(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_stage_file_download(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_sequence_done : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_sequence_done() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_PC_sequence_done() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_sequence_done(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_sequence_done(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::CmdSequenceDoneParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_payload_power_control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_payload_power_control() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_PC_payload_power_control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_payload_power_control(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_payload_power_control(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_response_health_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_response_health_check() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_PC_response_health_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_health_check(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespHealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_response_health_check(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespHealthCheckParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_response_shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_response_shutdown() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_PC_response_shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_shutdown(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_response_shutdown(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::RespShutdownParams* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PC_response_payload_metrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PC_response_payload_metrics() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_PC_response_payload_metrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_payload_metrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_response_payload_metrics(::grpc::ServerContext* context, ::antaris_api_peer_to_peer::PayloadMetricsResponse* request, ::grpc::ServerAsyncResponseWriter< ::antaris_api_peer_to_peer::AntarisReturnType>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_PC_register<WithAsyncMethod_PC_get_current_location<WithAsyncMethod_PC_stage_file_download<WithAsyncMethod_PC_sequence_done<WithAsyncMethod_PC_payload_power_control<WithAsyncMethod_PC_response_health_check<WithAsyncMethod_PC_response_shutdown<WithAsyncMethod_PC_response_payload_metrics<Service > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_PC_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_register() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ReqRegisterParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_register(context, request, response); }));}
    void SetMessageAllocatorFor_PC_register(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ReqRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_register(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_register(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_get_current_location : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_get_current_location() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_get_current_location(context, request, response); }));}
    void SetMessageAllocatorFor_PC_get_current_location(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_get_current_location() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_current_location(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_get_current_location(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_stage_file_download : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_stage_file_download() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_stage_file_download(context, request, response); }));}
    void SetMessageAllocatorFor_PC_stage_file_download(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ReqStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_stage_file_download() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_stage_file_download(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_stage_file_download(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_sequence_done : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_sequence_done() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::CmdSequenceDoneParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_sequence_done(context, request, response); }));}
    void SetMessageAllocatorFor_PC_sequence_done(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::CmdSequenceDoneParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::CmdSequenceDoneParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_sequence_done() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_sequence_done(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_sequence_done(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_payload_power_control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_payload_power_control() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_payload_power_control(context, request, response); }));}
    void SetMessageAllocatorFor_PC_payload_power_control(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_payload_power_control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_payload_power_control(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_payload_power_control(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_response_health_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_response_health_check() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespHealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespHealthCheckParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_response_health_check(context, request, response); }));}
    void SetMessageAllocatorFor_PC_response_health_check(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespHealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespHealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_response_health_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_health_check(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespHealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_response_health_check(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespHealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_response_shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_response_shutdown() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::RespShutdownParams* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_response_shutdown(context, request, response); }));}
    void SetMessageAllocatorFor_PC_response_shutdown(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::RespShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::RespShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_response_shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_shutdown(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_response_shutdown(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PC_response_payload_metrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PC_response_payload_metrics() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::PayloadMetricsResponse, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* request, ::antaris_api_peer_to_peer::AntarisReturnType* response) { return this->PC_response_payload_metrics(context, request, response); }));}
    void SetMessageAllocatorFor_PC_response_payload_metrics(
        ::grpc::MessageAllocator< ::antaris_api_peer_to_peer::PayloadMetricsResponse, ::antaris_api_peer_to_peer::AntarisReturnType>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::antaris_api_peer_to_peer::PayloadMetricsResponse, ::antaris_api_peer_to_peer::AntarisReturnType>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PC_response_payload_metrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_payload_metrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_response_payload_metrics(
      ::grpc::CallbackServerContext* /*context*/, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_PC_register<WithCallbackMethod_PC_get_current_location<WithCallbackMethod_PC_stage_file_download<WithCallbackMethod_PC_sequence_done<WithCallbackMethod_PC_payload_power_control<WithCallbackMethod_PC_response_health_check<WithCallbackMethod_PC_response_shutdown<WithCallbackMethod_PC_response_payload_metrics<Service > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_PC_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_register() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_PC_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_register(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_get_current_location : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_get_current_location() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_PC_get_current_location() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_current_location(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_stage_file_download : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_stage_file_download() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_PC_stage_file_download() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_stage_file_download(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_sequence_done : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_sequence_done() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_PC_sequence_done() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_sequence_done(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_payload_power_control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_payload_power_control() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_PC_payload_power_control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_payload_power_control(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_response_health_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_response_health_check() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_PC_response_health_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_health_check(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespHealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_response_shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_response_shutdown() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_PC_response_shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_shutdown(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PC_response_payload_metrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PC_response_payload_metrics() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_PC_response_payload_metrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_payload_metrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_register() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_PC_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_register(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_register(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_get_current_location : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_get_current_location() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_PC_get_current_location() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_current_location(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_get_current_location(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_stage_file_download : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_stage_file_download() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_PC_stage_file_download() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_stage_file_download(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_stage_file_download(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_sequence_done : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_sequence_done() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_PC_sequence_done() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_sequence_done(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_sequence_done(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_payload_power_control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_payload_power_control() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_PC_payload_power_control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_payload_power_control(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_payload_power_control(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_response_health_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_response_health_check() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_PC_response_health_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_health_check(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespHealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_response_health_check(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_response_shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_response_shutdown() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_PC_response_shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_shutdown(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_response_shutdown(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PC_response_payload_metrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PC_response_payload_metrics() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_PC_response_payload_metrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_payload_metrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPC_response_payload_metrics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_register() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_register(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_register(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_register(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_get_current_location : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_get_current_location() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_get_current_location(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_get_current_location() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_get_current_location(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_get_current_location(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_stage_file_download : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_stage_file_download() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_stage_file_download(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_stage_file_download() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_stage_file_download(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_stage_file_download(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_sequence_done : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_sequence_done() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_sequence_done(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_sequence_done() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_sequence_done(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_sequence_done(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_payload_power_control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_payload_power_control() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_payload_power_control(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_payload_power_control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_payload_power_control(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_payload_power_control(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_response_health_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_response_health_check() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_response_health_check(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_response_health_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_health_check(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespHealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_response_health_check(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_response_shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_response_shutdown() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_response_shutdown(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_response_shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_shutdown(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_response_shutdown(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PC_response_payload_metrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PC_response_payload_metrics() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PC_response_payload_metrics(context, request, response); }));
    }
    ~WithRawCallbackMethod_PC_response_payload_metrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PC_response_payload_metrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PC_response_payload_metrics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_register : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_register() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ReqRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ReqRegisterParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_register(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_register() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_register(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqRegisterParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_register(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ReqRegisterParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_get_current_location : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_get_current_location() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_get_current_location(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_get_current_location() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_get_current_location(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_get_current_location(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ReqGetCurrentLocationParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_stage_file_download : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_stage_file_download() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ReqStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ReqStageFileDownloadParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_stage_file_download(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_stage_file_download() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_stage_file_download(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqStageFileDownloadParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_stage_file_download(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ReqStageFileDownloadParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_sequence_done : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_sequence_done() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::CmdSequenceDoneParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::CmdSequenceDoneParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_sequence_done(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_sequence_done() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_sequence_done(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::CmdSequenceDoneParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_sequence_done(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::CmdSequenceDoneParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_payload_power_control : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_payload_power_control() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_payload_power_control(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_payload_power_control() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_payload_power_control(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_payload_power_control(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::ReqPayloadPowerControlParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_response_health_check : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_response_health_check() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespHealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespHealthCheckParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_response_health_check(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_response_health_check() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_response_health_check(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespHealthCheckParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_response_health_check(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespHealthCheckParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_response_shutdown : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_response_shutdown() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::RespShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::RespShutdownParams, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_response_shutdown(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_response_shutdown() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_response_shutdown(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::RespShutdownParams* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_response_shutdown(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::RespShutdownParams,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PC_response_payload_metrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PC_response_payload_metrics() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::antaris_api_peer_to_peer::PayloadMetricsResponse, ::antaris_api_peer_to_peer::AntarisReturnType>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::antaris_api_peer_to_peer::PayloadMetricsResponse, ::antaris_api_peer_to_peer::AntarisReturnType>* streamer) {
                       return this->StreamedPC_response_payload_metrics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PC_response_payload_metrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PC_response_payload_metrics(::grpc::ServerContext* /*context*/, const ::antaris_api_peer_to_peer::PayloadMetricsResponse* /*request*/, ::antaris_api_peer_to_peer::AntarisReturnType* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPC_response_payload_metrics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::antaris_api_peer_to_peer::PayloadMetricsResponse,::antaris_api_peer_to_peer::AntarisReturnType>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_PC_register<WithStreamedUnaryMethod_PC_get_current_location<WithStreamedUnaryMethod_PC_stage_file_download<WithStreamedUnaryMethod_PC_sequence_done<WithStreamedUnaryMethod_PC_payload_power_control<WithStreamedUnaryMethod_PC_response_health_check<WithStreamedUnaryMethod_PC_response_shutdown<WithStreamedUnaryMethod_PC_response_payload_metrics<Service > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_PC_register<WithStreamedUnaryMethod_PC_get_current_location<WithStreamedUnaryMethod_PC_stage_file_download<WithStreamedUnaryMethod_PC_sequence_done<WithStreamedUnaryMethod_PC_payload_power_control<WithStreamedUnaryMethod_PC_response_health_check<WithStreamedUnaryMethod_PC_response_shutdown<WithStreamedUnaryMethod_PC_response_payload_metrics<Service > > > > > > > > StreamedService;
};

}  // namespace antaris_api_peer_to_peer


#endif  // GRPC_defs_2fgen_2fproto_2fantaris_5fapi_2eproto__INCLUDED
